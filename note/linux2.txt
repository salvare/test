5-1 egrep 及 扩展正则表达式

1.[command] grep
*option:	-E	使用扩展正则表达式	即egrep命令
*option:	-A	after,同时显示 匹配到的行 的后几行 , 会有--表示分隔
		-B	before
		-C	context,同时显示上下的几行

扩展正则表达式
新增： +出现一或多次 	|或者	
() ? <> {}都不再需要转义


fgrep	fast	速度快，但不支持正则表达式


5-2 bash脚本编程 变量、变量类型

shell提供编程能力，脚本编程



编程语言 --编译器/解释器--> 机器语言

高级语言，机器语言，汇编语言

静态语言	编译型语言	强类型		事先转换为可执行文件，不再依赖其它	C,JAVA
动态语言	解释性语言	弱类型		边解释边执行，依赖解释器执行		SHELL,python,perl

shell脚本编程 中 bash就是解释器

变量：命名的 内存空间
内存：编址的存储单元

一个ASCII码占8bit，字符的存储基本单位是一字节byte
而数字最小存储单位是bit
变量类型：事先定义好数据的 存储格式和长度

缓冲区溢出攻击	存在于编译型语言，解释型语言采用了别的机制解决这个问题

逻辑运算有短路机制

强：变量需要声明，有的语言设置要初始化
若：不需要声明，设置不区分类型

bash变量类型：
	环境变量
	本地变量（局部变量）
	位置变量
	特殊变量（系统变量）

*创建变量：	例：# NAME=Jerry  # echo $NAME
*需要变量名避免歧义的话：	例：#echo "There are some ${ANIMAL}s"
*接上：		双引号""弱引用，可以替换变量
		单引号''强引用，不会解释变量
*本地变量：	# NAME=Jerry		作用域：整个bash进程
 局部变量：	# loacl NAME=Tom	作用域：只对当前 ？代码段？ 有效
*环境变量：	export NAME=Harry	作用域：当前进程和子进程
		或：# export NAME  # NAME='Hello'	注意：此处不加$

注意：变量是进程的变量，父bash中的变量 不能再子bash中读取



任何脚本执行时 会启动一个子shell进程
	命令行中启动的脚本会继承当前shell环境变量
	系统自动执行的脚本（非命令行启动），需要自己定义需要的环境变量

位置变量：
$1 $2

特殊命令：
$?	上一个命令的执行状态返回值	0-255	0表示正确	1，2，127为系统预留状态值，

/dev/null 软设备（软件模拟的设备）
*功能：	bit bucket	数据黑洞
*应用：	# id user1 &> /dev/null	有的情况不需要显示返回值


注销变量：
unset VARNAME

查看当前环境变量
printenv
env
export

查看当前shell所有变量
set

字符串变量可以方便的追加内容：
# ANIMAL='pig'  # ANIMAL=$ANIMAL:dog  # ANIMAL=${ANIMAL}cat

shell中默认所有变量类型都是字符串
# A=1  # B=2  # C=$A+$B  # echo $C  //result:2+3

脚本：命令的堆砌，按实际需要，结合命令流程机制
脚本中使用 # 注释行

shebang：魔数
#!/bin/bash

脚本写完之后是一个ASCII text文件，
linux的可执行文件是ELF，
所以给脚本文件的首行加上魔数，
机制：脚本文件提交给内核，内核发现不能执行，但是内核发现魔数，内核按指定的路径启动bash进程作为解释器

*nano后的文件没有x权限，手动加 chmod +x first.sh

执行：./first.sh	命令的路径如果在环境变量中 才可以 直接通过文件名执行

或者这样执行： bash first.sh	这种情况不需要first.sh有x权限


5-3 bash脚本编程 条件判断

1.条件测试
*整数测试	-eq -neq -gt -lt -ge -le
*字符测试
*文件测试

* [ expression ] 
* [[ expression ]]
* test expression


&& || 从左向右结合


A && B || C	if(A){ B }else{ C }
A || B && C	if(A){ C }elseif(B){ C }

if 判断条件; then
	echo 'xxx'
else
	xxx
fi

 














