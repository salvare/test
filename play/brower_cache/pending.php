<?php
require 'public.php';

/*
 * 现象：浏览器连续用在两个标签页 请求同一个URL，会发生第二次请求会被阻塞，直至第一次请求完成
 * 针对该现象进行的试验
 */

set_time_limit(0);
header('Cache-Control: max-age=300'); // 第一次请求的response控制使用缓存时，第二次请求才有可能取用

// exit('two'); // 用于 第二次访问，无sleep

sleep(15);
// sleep(30); // 会发现chrome在第二次请求`pending`20秒后，就不再等待，直接向服务器发出请求

exit('one');
?>
<!-- 

情景：当访问某耗时url时（如：sleep(20); ），第一次访问尚未结束，又用同一浏览器的另一标签页再次访问该url
现象：第二次请求会被挂起(pending)，直到第一次请求完成（详见下第1条），查看chrome的timing面板时，显示stalled时间（firefox看不到stalled时间）
调试：
1. chrome 和 firefox 现象相同（都会挂起，不过chrome最多20秒，firefox无限等）【注意：这是浏览器阻塞了请求的发出，不是服务器，所以占用脚本的执行时间限制`time_limit`】
2. 同域名下的其它页面访问正常，所以不是域名domain下的现象（不会是session引起的），而是访问同一url才会引起的
3. 在第一次请求后，修改url对应文件内容（输出改变，且取消sleep），再立刻在新标签页中作第二次请求，
   结果第一次请求的结果是修改前的内容（理所当然），第二次请求结果 是修改后的内容（不是在尝试获取前者的缓存【误】）
   
↑ 可能是因为我没有给页面加缓存，展开调试3：
情景：给页面加上缓存 header('Cache-Control: max-age=300');（提前试验过该控制对firefox有效，对chrome无效） ，在第一次请求后，修改url对应文件内容（输出改变），再立刻在新标签页中作第二次请求，
	注意：第一次用“圈”刷新，第二次用“回车”刷新，用“圈”刷新是一定不会用缓存的（尽管依然在等待第一次请求结束，这应该是个可以优化的地方）
现象：第二次请求 同样等待 第一次请求完成，并且输出同第一次请求 相同！

结论：
可以大胆猜测：浏览器在发生第二次请求时，发现此前已经请求过该资源一次，尽管结果还没有返回。
而且因为结果没有返回，也不知道reponse header中的缓存控制，所以第二次请求期待能直接从第一次请求中获得缓存结果；
    可以理解浏览器的这一行为，但是缺点是：如果response1控制不缓存，第二次就白等了。
该现象是浏览器行为，与服务器无关。不同的浏览器又经常有不同的行为，大概了解即可，不宜深究，结题。

 -->